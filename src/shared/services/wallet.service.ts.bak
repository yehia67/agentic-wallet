import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { SmartAccountProvider, LocalAccountSigner } from '@alchemy/aa-core';
import { createMultiOwnerMSCA } from '@alchemy/aa-accounts';
import {
  createPublicClient,
  getAddress,
  Hex,
  http,
  parseAbiItem,
  encodeFunctionData,
} from 'viem';
import { baseSepolia } from 'viem/chains';

@Injectable()
export class WalletService {
  private readonly logger = new Logger(WalletService.name);
  private publicClient: ReturnType<typeof createPublicClient>;
  private account: string;
  private smartAccountClient: SmartAccountProvider;
  private usdcAddress = '';
  private explorerUrl = '';

  constructor(private readonly configService: ConfigService) {
    this.initialize();
  }

  private async initialize() {
    try {
      const privateKey = this.configService.get<string>('PRIVATE_KEY');
      const apiKey = this.configService.get<string>('PIMLICO_API_KEY');
      const usdcAddress = this.configService.get<string>('BASE_SCAN_USDC');
      const explorerUrl = this.configService.get<string>('BASE_SCAN_EXPLORER');
      
      if (usdcAddress) this.usdcAddress = usdcAddress;
      if (explorerUrl) this.explorerUrl = explorerUrl;

      if (!privateKey || !apiKey) {
        this.logger.error(
          'Missing required environment variables for wallet initialization',
        );
        return;
      }

      // Initialize public client
      this.publicClient = createPublicClient({
        chain: baseSepolia,
        transport: http('https://sepolia.base.org'),
      });

      // Create the signer from private key
      const signer = new LocalAccountSigner({
        privateKey: privateKey as `0x${string}`,
      });

      // Create the provider URL with Pimlico API key
      const rpcUrl = `https://api.pimlico.io/v1/base-sepolia/rpc?apikey=${apiKey}`;

      // Create the Smart Account Provider
      const provider = new SmartAccountProvider({
        rpcProvider: rpcUrl,
        entryPointAddress: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789', // EntryPoint v0.7 address
        chain: baseSepolia,
      });
      
      // Connect the provider with the multi-owner account
      const connectedProvider = provider.connect(
        async (provider) => {
          return createMultiOwnerMSCA({
            owner: signer,
            provider,
            entryPointAddress: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',
          });
        }
      );

      // Store the account and client
      this.account = await connectedProvider.getAddress();
      this.smartAccountClient = connectedProvider;

      this.logger.log(`Smart account initialized: ${this.account}`);
    } catch (error) {
      this.logger.error(
        `Error initializing wallet service: ${error.message}`,
        error.stack,
      );
    }
  }

  /**
   * Get the wallet address
   */
  async getWalletAddress(): Promise<string> {
    if (!this.account) {
      throw new Error('Wallet not initialized');
    }
    return this.account;
  }

  /**
   * Get the wallet balance in USDC
   */
  async getUsdcBalance(): Promise<number> {
    if (!this.account || !this.publicClient) {
      throw new Error('Wallet not initialized');
    }

    try {
      const balance = await this.publicClient.readContract({
        abi: [
          parseAbiItem('function balanceOf(address account) returns (uint256)'),
        ],
        address: this.usdcAddress as `0x${string}`,
        functionName: 'balanceOf',
        args: [this.account],
      });

      return Number(balance) / 1_000_000; // Convert from USDC's 6 decimals to human-readable format
    } catch (error) {
      this.logger.error(
        `Error getting USDC balance: ${error.message}`,
        error.stack,
      );
      throw new Error(`Failed to get USDC balance: ${error.message}`);
    }
  }

  /**
   * Send a transaction with the smart account
   */
  async sendTransaction(to: string, data = '0x'): Promise<string> {
    if (!this.smartAccountClient) {
      throw new Error('Smart account client not initialized');
    }

    try {
      const txResponse = await this.smartAccountClient.sendTransaction({
        to: getAddress(to),
        value: 0n,
        data: data as Hex,
      });

      // For Alchemy Account Kit, the response is the transaction hash
      const txHash = txResponse;

      this.logger.log(`Transaction sent: ${txHash}`);
      return txHash;
    } catch (error) {
      this.logger.error(
        `Error sending transaction: ${error.message}`,
        error.stack,
      );
      throw new Error(`Failed to send transaction: ${error.message}`);
    }
  }

  /**
   * Approve a token for spending by a contract
   */
  async approveToken(
    spender: string,
    amount: bigint = 2n ** 256n - 1n,
  ): Promise<string> {
    if (!this.smartAccountClient) {
      throw new Error('Smart account client not initialized');
    }

    try {
      const txResponse = await this.smartAccountClient.sendTransaction({
        to: getAddress(this.usdcAddress),
        value: 0n,
        data: encodeFunctionData({
          abi: [
            parseAbiItem('function approve(address spender, uint256 amount)'),
          ],
          functionName: 'approve',
          args: [getAddress(spender), amount],
        }),
      });

      // For Alchemy Account Kit, the response is the transaction hash
      const txHash = txResponse;

      this.logger.log(`Token approval transaction sent: ${txHash}`);
      return txHash;
    } catch (error) {
      this.logger.error(`Error approving token: ${error.message}`, error.stack);
      throw new Error(`Failed to approve token: ${error.message}`);
    }
  }

  /**
   * Execute multiple transactions in a batch
   */
  async batchTransactions(
    transactions: Array<{ to: string; value?: bigint; data?: string }>,
  ): Promise<string> {
    if (!this.smartAccountClient) {
      throw new Error('Smart account client not initialized');
    }

    try {
      // The Alchemy Account Kit doesn't support batched transactions directly in the same way
      // So we need to create a batch transaction manually
      if (transactions.length === 0) {
        throw new Error('No transactions provided');
      }
      
      if (transactions.length === 1) {
        // If there's only one transaction, send it directly
        const tx = transactions[0];
        const txResponse = await this.smartAccountClient.sendTransaction({
          to: getAddress(tx.to),
          value: tx.value || 0n,
          data: (tx.data || '0x') as Hex,
        });
        
        // For Alchemy Account Kit, the response is the transaction hash
        const txHash = txResponse;
        
        this.logger.log(`Transaction sent: ${txHash}`);
        return txHash;
      } else {
        // For multiple transactions, we need to send them sequentially
        // This is a simplified implementation - in a real app, you might want to use a multicall contract
        const txPromises = transactions.map(async (tx) => {
          return this.smartAccountClient.sendTransaction({
            to: getAddress(tx.to),
            value: tx.value || 0n,
            data: (tx.data || '0x') as Hex,
          });
        });
        
        // Execute all transactions and get the last hash
        const txHashes = await Promise.all(txPromises);
        const lastTxHash = txHashes[txHashes.length - 1];
        
        this.logger.log(`Batch transactions sent, last hash: ${lastTxHash}`);
        return lastTxHash;
      }
    } catch (error) {
      this.logger.error(
        `Error sending batch transactions: ${error.message}`,
        error.stack,
      );
      throw new Error(`Failed to send batch transactions: ${error.message}`);
    }
  }

  /**
   * Get transaction URL in block explorer
   */
  getTransactionUrl(txHash: string): string {
    return `${this.explorerUrl}/tx/${txHash}`;
  }

  /**
   * Get wallet address URL in block explorer
   */
  getWalletUrl(): string {
    if (!this.account) {
      throw new Error('Wallet not initialized');
    }
    return `${this.explorerUrl}/address/${this.account.address}`;
  }
}
